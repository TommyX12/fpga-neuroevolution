

floating point arithmetic with 'real' datatype


standardized datapath access
    start signal to datapath
    finished signal from datapath
    instruction to datapath
        32 bit standardized instruction for doing anything, such as memory read, write, write to screen, etc.
        highest 4 bits: opcode: determines operation to use.
            0: do nothing.
            1: draw to frame buffer.
                bit 0-7: x
                bit 8-14: y
                bit 15-17: color
                bit 18: plot
                
            2: read from memory
                bit 0-15: address
                
            3: write to memory
                bit 0-15: address
                bit 16-27: value
                
            4: output frame buffer
                bit 0-7: x
                bit 8-14: y
                
            5: 
            6: 
            7: 
            8: 
            9: 
            10: 
            11: 
            12: 
            13: 
            14: 
            15: 
    
    return value from datapath
        32 bit value corresponding to each possible operation in the instruction to datapath

datapath multiplexer for concurrent access control.
    generate for arbitrary number of inputs.
    multiplex each of the 4 standard signals for datapath access, for each input.
    scan for an input that has unfinished instruction. pass its instructions to datapath and wait for output, then put that into the corresponding output to that input and set finished for it. repeat.
    
    !!! this is essential so make sure this is actually working.
    
// !!! make a frame buffer that act the same as vga adapter but is just a memory. all draw now draw to frame buffer, and final step draw from frame buffer to screen.

!!! use numerous memory locator module to find where memory are suppose to be stored.
    !!! let Ian do this
    !!! maybe setup in main and all connect outward to singleton version of those separate locator module.
    module AntPoisonEatenAddr(
        input id,
        output [15:0] address
    )

!!! random number generator
    ? available as datapath operation, or simply connection.
    
    module random (clock, resetn, data);
        parameter bits;
        
        input clock;
        input resetn;
        
        output reg data;
        
        // TODO add your stuff here
    
    endmodule;

structs:
    ant:
        x, y, food eaten, poison eaten, current fitness
    
    food:
        x, y
        
    poison:
        x, y
    
    neural network weights are stored in ant update module locally.

main loop:
    // logic
    GA update
        if times up for a generation, compute next generation.
        if it's the first generation
            randomize all ant, food, poison location
            randomize the neural network weights.
        
        else:
            
        
        finally:
            set foot eaten, poison eaten, current fitness to 0.
        
        !!! note:
        this module connects to a register of all weights of every neural network (in main module).
        it also stores a copy buffer
        
    ant update (parallel for each ant)
        test if food collide.
            if yes, change food to another random location, update current food eaten count. store to memory.
            in the same step, retrieve closest food location.
                
        test if poison collide.
            if yes, change poison to another random location, update current poison eaten count. store to memory.
            in the same step, retrieve closest poison location.
        
        compute current fitness, store to memory
        
        run neural network
        
        move depending on output
        
        !!! note:
        this module stores all connections of the neural network
        
    // drawing
    background draw
    ant draw
    food draw
    poison draw
    output frame buffer
    
    // fps control
    limit fps
