

floating point arithmetic with 'real' datatype


standardized datapath access
    start signal to datapath
    finished signal from datapath
    instruction to datapath
        32 bit standardized instruction for doing anything, such as memory read, write, write to screen, etc.
        lowest [3:0] bits: opcode: determines operation to use.
            0: do nothing.
            1: draw to frame buffer.
                bit [11:4]: x
                bit [18:12]: y
                bit [21:19]: color
                bit 22: plot
                
            2: read from memory
                bit [19:4]: address
                
            3: write to memory
                bit [19:4]: address
                bit [31:20]: value
                
            4: output frame buffer
                bit [11:4]: x
                bit [18:12]: y
                
            5: 
            6: 
            7: 
            8: 
            9: 
            10: 
            11: 
            12: 
            13: 
            14: 
            15: 
    
    return value from datapath
        32 bit value corresponding to each possible operation in the instruction to datapath

datapath multiplexer for concurrent access control.
    generate for arbitrary number of inputs.
    multiplex each of the 4 standard signals for datapath access, for each input.
    scan for an input that has unfinished instruction. pass its instructions to datapath and wait for output, then put that into the corresponding output to that input and set finished for it. repeat.
    
    !!! this is essential so make sure this is actually working.
    
// !!! make a frame buffer that act the same as vga adapter but is just a memory. all draw now draw to frame buffer, and final step draw from frame buffer to screen.

!!! use numerous memory locator macro to find where memory are suppose to be stored.
    !!! let Ian do this

!!! random number generator
    ? available as datapath operation, or simply connection.
    
    module random (clock, resetn, data);
        parameter bits;
        
        input clock;
        input resetn;
        
        output reg data;
        
        // TODO add your stuff here
    
    endmodule;

structs:
    ant:
        x, y, food eaten, poison eaten, current fitness
    
    food:
        x, y
        
    poison:
        x, y
    
    neural network weights are stored in ant update module locally.

!!! note:
    GA update stores all weights of the neural network.
    and each ant module connects to one of them.
    GA also stores a copy buffer, used in copying.
    
    !!! make sure to use advanced physical optimization on final compilation.

main loop:
    // logic
    GA update
        if generation timer is not 30 seconds yet, finish immediately.
        otherwise increase generation timer by 1.
            
        if it's the first generation
            randomize all ant, food, poison location
            randomize the neural network weights.
        
        else:
            for each ant:
                // perform roulette wheel selection to find parent ant.
                // try the following in a single cycle.
                get rand = random number.
                sum = 0
                id = 0
                for each ant:
                    if rand >= sum and rand < sum + ant.fitness:
                        id = current id
                    
                    sum += ant.fitness
                
                copy parent weight to buffer[ant id] weight.
                
            apply mutation to each weight in the buffer.
                // might need multiple cycles
                
            copy buffer weight to main weights.
        
        finally:
            set generation timer = 0.
            set foot eaten, poison eaten, current fitness to 0.
        
    ant update (parallel for each ant)
        test if food collide.
            if yes, change food to another random location, update current food eaten count. store to memory.
            in the same step, retrieve closest food location.
                
        test if poison collide.
            if yes, change poison to another random location, update current poison eaten count. store to memory.
            in the same step, retrieve closest poison location.
        
        compute current fitness, store to memory
        
        run neural network
        
        move depending on output
        
        !!! note:
        this module stores all connections of the neural network
        
    // drawing
    background draw
    ant draw
    food draw
    poison draw
    output frame buffer
    
    // fps control
    limit fps
